import { pgTable, index, foreignKey, serial, integer, varchar, text, unique, boolean, jsonb, bigint } from "drizzle-orm/pg-core"


export const uniprotIdentifiers = pgTable("uniprot_identifiers", {
	id: serial().primaryKey().notNull(),
	proteinId: integer("protein_id"),
	uniprotAccession: varchar("uniprot_accession", { length: 30 }).notNull(),
	identifierValue: text("identifier_value").notNull(),
	identifierType: varchar("identifier_type", { length: 50 }).notNull(),
	taxonId: text("taxon_id"),
}, (table) => [
	index("idx_uniprot_identifiers_protein_id").using("btree", table.proteinId.asc().nullsLast().op("int4_ops")),
	index("idx_uniprot_identifiers_value_prefix").using("btree", table.identifierValue.asc().nullsLast().op("text_pattern_ops")),
	index("idx_uniprot_identifiers_value_trgm").using("gin", table.identifierValue.asc().nullsLast().op("gin_trgm_ops")),
	foreignKey({
			columns: [table.proteinId],
			foreignColumns: [uniprotProteins.id],
			name: "uniprot_identifiers_protein_id_fkey"
		}).onDelete("cascade"),
]);

export const uniprotProteins = pgTable("uniprot_proteins", {
	id: serial().primaryKey().notNull(),
	entry: varchar({ length: 30 }).notNull(),
	entryName: text("entry_name"),
	proteinNames: text("protein_names"),
	length: integer(),
	mass: integer(),
	sequence: text(),
	geneNamesPrimary: text("gene_names_primary"),
	geneNamesSynonym: text("gene_names_synonym"),
	organismId: text("organism_id"),
	involvementInDisease: text("involvement_in_disease"),
	mutagenesis: text(),
	subcellularLocation: text("subcellular_location"),
	postTranslationalModification: text("post_translational_modification"),
	pubmedId: text("pubmed_id"),
	functionCc: text("function_cc"),
	ensembl: text(),
	kegg: text(),
	pathway: text(),
	activityRegulation: text("activity_regulation"),
	keywords: text(),
	ecNumber: text("ec_number"),
	geneOntology: text("gene_ontology"),
	transmembrane: text(),
	proteinFamilies: text("protein_families"),
	refseq: text(),
	alphafolddb: varchar({ length: 30 }),
	pdb: text(),
	chembl: text(),
	phosphositeplus: text(),
	signor: text(),
	pathwaycommons: text(),
	intact: text(),
	biogrid: text(),
	complexportal: text(),
}, (table) => [
	index("idx_uniprot_proteins_entry").using("btree", table.entry.asc().nullsLast().op("text_ops")),
	unique("uniprot_proteins_entry_key").on(table.entry),
]);

export const complexes = pgTable("complexes", {
	id: serial().primaryKey().notNull(),
	name: text(),
	components: text(),
	componentsGenesymbols: text("components_genesymbols"),
	stoichiometry: text(),
	sources: text(),
	references: text(),
	identifiers: text(),
}, (table) => [
	index("idx_complexes_name").using("btree", table.name.asc().nullsLast().op("text_ops")),
	index("idx_complexes_sources").using("btree", table.sources.asc().nullsLast().op("text_ops")),
]);

export const enzSub = pgTable("enz_sub", {
	id: serial().primaryKey().notNull(),
	enzyme: text(),
	enzymeGenesymbol: text("enzyme_genesymbol"),
	substrate: text(),
	substrateGenesymbol: text("substrate_genesymbol"),
	isoforms: text(),
	residueType: varchar("residue_type", { length: 10 }),
	residueOffset: integer("residue_offset"),
	modification: text(),
	sources: text(),
	references: text(),
	curationEffort: integer("curation_effort"),
	ncbiTaxId: integer("ncbi_tax_id"),
}, (table) => [
	index("idx_enz_sub_enzyme").using("btree", table.enzyme.asc().nullsLast().op("text_ops")),
	index("idx_enz_sub_enzyme_genesymbol").using("btree", table.enzymeGenesymbol.asc().nullsLast().op("text_ops")),
	index("idx_enz_sub_substrate").using("btree", table.substrate.asc().nullsLast().op("text_ops")),
	index("idx_enz_sub_substrate_genesymbol").using("btree", table.substrateGenesymbol.asc().nullsLast().op("text_ops")),
]);

export const intercell = pgTable("intercell", {
	id: serial().primaryKey().notNull(),
	category: text(),
	parent: text(),
	database: text(),
	scope: text(),
	aspect: text(),
	source: text(),
	uniprot: text(),
	genesymbol: text(),
	entityType: varchar("entity_type", { length: 50 }),
	consensusScore: integer("consensus_score"),
	transmitter: boolean(),
	receiver: boolean(),
	secreted: boolean(),
	plasmaMembraneTransmembrane: boolean("plasma_membrane_transmembrane"),
	plasmaMembranePeripheral: boolean("plasma_membrane_peripheral"),
}, (table) => [
	index("idx_intercell_category").using("btree", table.category.asc().nullsLast().op("text_ops")),
	index("idx_intercell_database").using("btree", table.database.asc().nullsLast().op("text_ops")),
	index("idx_intercell_genesymbol").using("btree", table.genesymbol.asc().nullsLast().op("text_ops")),
	index("idx_intercell_uniprot").using("btree", table.uniprot.asc().nullsLast().op("text_ops")),
]);

export const interactions = pgTable("interactions", {
	id: serial().primaryKey().notNull(),
	source: text(),
	target: text(),
	sourceGenesymbol: text("source_genesymbol"),
	targetGenesymbol: text("target_genesymbol"),
	isDirected: boolean("is_directed"),
	isStimulation: boolean("is_stimulation"),
	isInhibition: boolean("is_inhibition"),
	consensusDirection: boolean("consensus_direction"),
	consensusStimulation: boolean("consensus_stimulation"),
	consensusInhibition: boolean("consensus_inhibition"),
	sources: text(),
	references: text(),
	omnipath: boolean(),
	kinaseextra: boolean(),
	ligrecextra: boolean(),
	pathwayextra: boolean(),
	mirnatarget: boolean(),
	dorothea: boolean(),
	collectri: boolean(),
	tfTarget: boolean("tf_target"),
	lncrnaMrna: boolean("lncrna_mrna"),
	tfMirna: boolean("tf_mirna"),
	smallMolecule: boolean("small_molecule"),
	dorotheaCurated: boolean("dorothea_curated"),
	dorotheaChipseq: boolean("dorothea_chipseq"),
	dorotheaTfbs: boolean("dorothea_tfbs"),
	dorotheaCoexp: boolean("dorothea_coexp"),
	dorotheaLevel: varchar("dorothea_level", { length: 10 }),
	type: text(),
	curationEffort: integer("curation_effort"),
	extraAttrs: jsonb("extra_attrs"),
	evidences: jsonb(),
	ncbiTaxIdSource: integer("ncbi_tax_id_source"),
	entityTypeSource: varchar("entity_type_source", { length: 50 }),
	ncbiTaxIdTarget: integer("ncbi_tax_id_target"),
	entityTypeTarget: varchar("entity_type_target", { length: 50 }),
}, (table) => [
	index("idx_interactions_pair").using("btree", table.source.asc().nullsLast().op("text_ops"), table.target.asc().nullsLast().op("text_ops")),
	index("idx_interactions_source").using("btree", table.source.asc().nullsLast().op("text_ops")),
	index("idx_interactions_source_genesymbol").using("btree", table.sourceGenesymbol.asc().nullsLast().op("text_ops")),
	index("idx_interactions_sources").using("btree", table.sources.asc().nullsLast().op("text_ops")),
	index("idx_interactions_target").using("btree", table.target.asc().nullsLast().op("text_ops")),
	index("idx_interactions_target_genesymbol").using("btree", table.targetGenesymbol.asc().nullsLast().op("text_ops")),
	index("idx_interactions_type").using("btree", table.type.asc().nullsLast().op("text_ops")),
]);

export const annotations = pgTable("annotations", {
	id: serial().primaryKey().notNull(),
	uniprot: text(),
	genesymbol: text(),
	entityType: varchar("entity_type", { length: 50 }),
	source: text(),
	label: text(),
	value: text(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	recordId: bigint("record_id", { mode: "number" }),
}, (table) => [
	index("idx_annotations_genesymbol").using("btree", table.genesymbol.asc().nullsLast().op("text_ops")),
	index("idx_annotations_label").using("btree", table.label.asc().nullsLast().op("text_ops")),
	index("idx_annotations_source").using("btree", table.source.asc().nullsLast().op("text_ops")),
	index("idx_annotations_uniprot").using("btree", table.uniprot.asc().nullsLast().op("text_ops")),
]);
